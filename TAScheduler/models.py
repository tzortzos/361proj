from django.db import models


class UserType(models.TextChoices):
    ADMIN = "A", "Administrator"
    PROF = "P", "Professor"
    TA = "T", "TA"

    @classmethod
    def from_str(cls, maybe_type: str):
        if maybe_type == 'A':
            return UserType.ADMIN
        elif maybe_type == 'P':
            return UserType.PROF
        elif maybe_type == 'T':
            return UserType.TA
        else:
            raise TypeError(f'user_type {maybe_type} is non in the set of [A, P, T]')

class User(models.Model):
    """
    Represents all three types of user of our application
    """
    user_id = models.AutoField('User ID (Autogenerated)', primary_key=True)
    type = models.CharField('User Type', max_length=1, choices=UserType.choices, blank=False)

    """The first part of the university email"""
    univ_id = models.CharField('University ID', max_length=20, blank=False)

    l_name = models.CharField('Last Name', max_length=20, blank=True)
    f_name = models.CharField('First Name', max_length=20, blank=True)

    phone = models.CharField(max_length=10, blank=True)

    description = models.TextField('Extra skills and information', max_length=500, blank=True, default='')

    """
    Output of a Password Hasher
    see: https://docs.djangoproject.com/en/3.2/topics/auth/passwords/
    """
    password = models.CharField(max_length=64, blank=False)
    tmp_password = models.BooleanField(default=True, blank=False)

    def __str__(self):
        return f'{self.f_name} {self.l_name} ({self.univ_id}@umw.edu) [{self.get_type_display()}]'


class Course(models.Model):
    """
    Represents an Abstract Course (Software Engineering 361) which may have multiple
    Course Sections(online,12-2 MW,etc.)
    """

    course_id = models.AutoField('Course Id (Autogenerated)', primary_key=True)
    course_code = models.CharField('Course Code', max_length=4, blank=False)
    course_name = models.TextField('Course Name', max_length=40, blank=False)
    admin_id = models.ForeignKey(User, on_delete=models.SET_NULL, blank=True, null=True)

    def __str__(self):
        return f'({self.course_code}) {self.course_name}'


class CourseSection(models.Model):
    """
    Represents an Abstract Course Section (section 201 of CS361) which may have multiple Lab Sections
    associated to it.
    """

    #course_id is bad!!List things from need to input to optional/default
    course_section_id = models.AutoField('Course Section ID', primary_key=True)
    course_section_code = models.CharField('Course Section Code', blank=False, max_length=3)
    lecture_days = models.CharField('Lecture Day(s)', blank=True, max_length=6)
    lecture_time = models.TextField('Lecture Time', blank=True, max_length=12)
    course_id = models.ForeignKey(Course, on_delete=models.CASCADE, blank=False, help_text="Course ID")
    instructor_id = models.ForeignKey(User, on_delete=models.SET_NULL, blank=True, null=True,
                                      help_text="Instructor ID")

    ta_ids = models.ManyToManyField(User, through='Assignment', related_name='section_assign', blank=True,
                                    help_text='Ta\'s Assigned to this Course Section')

    class Meta:
        # Adds a unique constraint combination on the two fields
        unique_together = ['course_section_code', 'course_id']

    def __str__(self):
        return f'{self.course_id.course_code} section {self.course_section_code} [{self.instructor_id}]'


class Assignment(models.Model):
    ta = models.ForeignKey(User)
    section = models.ForeignKey(CourseSection)
    max_labs = models.IntegerField(verbose_name='Maximum number of labs that this TA can be assigned', blank=False)


class Lab(models.Model):
    """
    Represent an Abstract Lab Section (lab section 901, 902, etc.. for Course section 201, Course CS361)
    """

    id = models.AutoField('Lab Section ID', primary_key=True)
    code = models.CharField('Lab Section Code', blank=False, max_length=3)
    day = models.CharField('Lab Day(s)', blank=True, max_length=6)
    time = models.TextField('Lab Time', blank=True, max_length=12)
    course = models.ForeignKey('CourseSection', on_delete=models.CASCADE, blank=False,
                               help_text="Course Section ID")
    ta = models.ForeignKey('User', on_delete=models.SET_NULL, blank=True, null=True,
                           help_text="TA ID")

    class Meta:
        # Adds a unique constraint combination on the two fields
        unique_together = ['lab_section_code', 'course_section_id']

    def __str__(self):
        return f'{self.course.course_id.course_code} section {self.course.course_section_code} lab {self.code}'
